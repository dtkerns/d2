%You can copy bibtex citations directly from Google Scholar. Enable through: Settings -> Show links to import ...[Bibtex]; Search for paper title and the bibtex link should appear. Click on it, and copy/past here.

@book{Hennessy_Patterson_2019,
  address={New York},
  title={A new golden age for computer architecture},
  volume={62},
  ISSN={0001-0782},
  DOI={10.1145/3282307},
  number={2},
  journal={Communications of the ACM},
  publisher={ACM},
  author={Hennessy, John and Patterson, David},
  year={2019},
  pages={48–60},
  keywords={Computer architecture ; Computer interfaces ; Computer security ; Design and construction ; Forecasts and trends ; Innovations ; Interfaces ; Open systems (Computers) ; Software ; Systems design},
  language={eng}
}

@inproceedings{guo04_fpgaAdvantages,
  title={A quantitative analysis of the speedup factors of FPGAs over processors},
  author={Guo, Zhi and Najjar, Walid and Vahid, Frank and Vissers, Kees},
  booktitle={Proceedings of the 2004 ACM/SIGDA 12th international symposium on Field programmable gate arrays},
  pages={162--170},
  year={2004},
  isbn = {1581138296},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/968280.968304},
  doi = {10.1145/968280.968304},
  numpages = {9},
  keywords = {analysis, reconfigurable computing, FPGA, VHDL, performance},
  location = {Monterey, California, USA},
  abstract = {The speedup over a microprocessor that can be achieved by implementing some programs on an FPGA has been extensively reported. This paper presents an analysis, both quantitative and qualitative, at the architecture level of the components of this speedup. Obviously, the spatial parallelism that can be exploited on the FPGA is a big component. By itself, however, it does not account for the whole speedup.In this paper we experimentally analyze the remaining components of the speedup. We compare the performance of image processing application programs executing in hardware on a Xilinx Virtex E2000 FPGA to that on three general-purpose processor platforms: MIPS, Pentium III and VLIW. The question we set out to answer is what is the inherent advantage of a hardware implementation over a von Neumann platform. On the one hand, the clock frequency of general-purpose processors is about 20 times that of typical FPGA implementations. On the other hand, the iteration level parallelism on the FPGA is one to two orders of magnitude that on the CPUs. In addition to these two factors, we identify the efficiency advantage of FPGAs as an important factor and show that it ranges from 6 to 47 on our test benchmarks. We also identify some of the components of this factor: the streaming of data from memory, the overlap of control and data flow and the elimination of some instruction on the FPGA. The results provide a deeper understanding of the tradeoff between system complexity and performance when designing Configurable SoC as well as designing software for CSoC. They also help understand the one to two orders of magnitude in speedup of FPGAs over CPU after accounting for clock frequencies.},
  series = {FPGA '04}
}

@misc{xilinx21_vivado_hls,
title = {Introduction to FPGA Design with Vivado High-Level Synthesis},
url = {https://docs.xilinx.com/v/u/en-US/ug998-vivado-intro-fpga-design-hls},
publisher = {Xilinx},
author = {Xilinx, I},
year = {2021},
abstract = {Software is the basis of all applications. Whether for entertainment, gaming,
communications, or medicine, many of the products people use today began as a software
model or prototype. Based on the performance and programmability constraints of the
system, the software engineer is tasked with determining the best implementation platform
to get a project to market. To accomplish this task, the software engineer is aided by both
programming techniques and a variety of hardware processing platforms.}
}

@article{canis13_legup,
author = {Canis, Andrew and Choi, Jongsok and Aldham, Mark and Zhang, Victor and Kammoona, Ahmed and Czajkowski, Tomasz and Brown, Stephen D. and Anderson, Jason H.},
title = {LegUp: An Open-Source High-Level Synthesis Tool for FPGA-Based Processor/Accelerator Systems},
year = {2013},
issue_date = {September 2013},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {13},
number = {2},
issn = {1539-9087},
url = {https://doi.org/10.1145/2514740},
doi = {10.1145/2514740},
abstract = {It is generally accepted that a custom hardware implementation of a set of computations will provide superior speed and energy efficiency relative to a software implementation. However, the cost and difficulty of hardware design is often prohibitive, and consequently, a software approach is used for most applications. In this article, we introduce a new high-level synthesis tool called LegUp that allows software techniques to be used for hardware design. LegUp accepts a standard C program as input and automatically compiles the program to a hybrid architecture containing an FPGA-based MIPS soft processor and custom hardware accelerators that communicate through a standard bus interface. In the hybrid processor/accelerator architecture, program segments that are unsuitable for hardware implementation can execute in software on the processor. LegUp can synthesize most of the C language to hardware, including fixed-sized multidimensional arrays, structs, global variables, and pointer arithmetic. Results show that the tool produces hardware solutions of comparable quality to a commercial high-level synthesis tool. We also give results demonstrating the ability of the tool to explore the hardware/software codesign space by varying the amount of a program that runs in software versus hardware. LegUp, along with a set of benchmark C programs, is open source and freely downloadable, providing a powerful platform that can be leveraged for new research on a wide range of high-level synthesis topics.},
journal = {ACM Trans. Embed. Comput. Syst.},
month = {sep},
articleno = {24},
numpages = {27},
keywords = {FPGAs, performance, field-programmable gate arrays, High-level synthesis, hardware/software codesign, synthesis, power}
}

@INPROCEEDINGS{limaye21_dosage,
  author={Limaye, Ankur and Adegbija, Tosiron},
  booktitle={2021 IEEE/ACM International Symposium on Low Power Electronics and Design (ISLPED)}, 
  title={DOSAGE: Generating Domain-Specific Accelerators for Resource-Constrained Computing}, 
  year={2021},
  volume={},
  number={},
  pages={1-6},
  doi={10.1109/ISLPED52811.2021.9502501}}

@ARTICLE{limay18_hermit,
  author={Limaye, Ankur and Adegbija, Tosiron},
  journal={IEEE Internet of Things Journal},
  title={HERMIT: A Benchmark Suite for the Internet of Medical Things},
  year={2018},  volume={5},  number={5},  pages={4212-4222},
  doi={10.1109/JIOT.2018.2849859}}

@article{gansner17_graphviz,
  author    = {Emden R. Gansner and
               Eleftherios Koutsofios and
               Stephen C. North and
               Kiem{-}Phong Vo},
  title     = {A Technique for Drawing Directed Graphs},
  journal   = {{IEEE} Trans. Software Eng.},
  volume    = {19},
  number    = {3},
  pages     = {214--230},
  year      = {1993},
  url       = {https://doi.org/10.1109/32.221135},
  doi       = {10.1109/32.221135},
  timestamp = {Wed, 17 May 2017 10:56:38 +0200},
  biburl    = {https://dblp.org/rec/journals/tse/GansnerKNV93.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@misc{gansner2006drawing,
  title={Drawing graphs with dot},
  author={Gansner, Emden and Koutsofios, Eleftherios and North, Stephen},
  year={2006},
  publisher={Technical report, AT\&T Research},
  url={https://graphviz.org/documentation/}
}

@online{ref22_llvmwebsiteabs,
    title = "LLVM Language Reference Manual",
    url  = "https://llvm.org/docs/LangRef.html#abstract",
    addendum = "(accessed: 06.01.2022)",
    keywords = "llvm, SSA"
}

@online{ref22_llvmwebsiteintro,
    title = "LLVM Language Reference Manual",
    url  = "https://llvm.org/docs/LangRef.html#introduction",
    addendum = "(accessed: 06.01.2022)",
    keywords = "llvm, IR"
}

@INPROCEEDINGS{guthaus01_mibench,
  author={Guthaus, M.R. and Ringenberg, J.S. and Ernst, D. and Austin, T.M. and Mudge, T. and Brown, R.B.},
  booktitle={Proceedings of the Fourth Annual IEEE International Workshop on Workload Characterization. WWC-4 (Cat. No.01EX538)},
  title={MiBench: A free, commercially representative embedded benchmark suite},
  year={2001},  volume={},  number={},  pages={3-14},
  doi={10.1109/WWC.2001.990739}}

@INPROCEEDINGS{karageorgos20_hwsw_bci,
  author={Karageorgos, Ioannis and Sriram, Karthik and Veselý, Ján and Wu, Michael and Powell, Marc and Borton, David and Manohar, Rajit and Bhattacharjee, Abhishek},
  booktitle={2020 ACM/IEEE 47th Annual International Symposium on Computer Architecture (ISCA)}, 
  title={Hardware-Software Co-Design for Brain-Computer Interfaces}, 
  year={2020},
  volume={},
  number={},
  pages={391-404},
  doi={10.1109/ISCA45697.2020.00041}}

@article{binkert11_gem5,
author = {Binkert, Nathan and Beckmann, Bradford and Black, Gabriel and Reinhardt, Steven K. and Saidi, Ali and Basu, Arkaprava and Hestness, Joel and Hower, Derek R. and Krishna, Tushar and Sardashti, Somayeh and Sen, Rathijit and Sewell, Korey and Shoaib, Muhammad and Vaish, Nilay and Hill, Mark D. and Wood, David A.},
title = {The Gem5 Simulator},
year = {2011},
issue_date = {May 2011},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {39},
number = {2},
issn = {0163-5964},
url = {https://doi.org/10.1145/2024716.2024718},
doi = {10.1145/2024716.2024718},
abstract = {The gem5 simulation infrastructure is the merger of the best aspects of the M5 [4] and GEMS [9] simulators. M5 provides a highly configurable simulation framework, multiple ISAs, and diverse CPU models. GEMS complements these features with a detailed and exible memory system, including support for multiple cache coherence protocols and interconnect models. Currently, gem5 supports most commercial ISAs (ARM, ALPHA, MIPS, Power, SPARC, and x86), including booting Linux on three of them (ARM, ALPHA, and x86).The project is the result of the combined efforts of many academic and industrial institutions, including AMD, ARM, HP, MIPS, Princeton, MIT, and the Universities of Michigan, Texas, and Wisconsin. Over the past ten years, M5 and GEMS have been used in hundreds of publications and have been downloaded tens of thousands of times. The high level of collaboration on the gem5 project, combined with the previous success of the component parts and a liberal BSD-like license, make gem5 a valuable full-system simulation tool.},
journal = {SIGARCH Comput. Archit. News},
month = {aug},
pages = {1–7},
numpages = {7}
}

@inproceedings{kumar17_needle,
  title={Needle: Leveraging program analysis to analyze and extract accelerators from whole programs},
  author={Kumar, Snehasish and Sumner, Nick and Srinivasan, Vijayalakshmi and Margerm, Steve and Shriraman, Arrvindh},
  booktitle={2017 IEEE International Symposium on High Performance Computer Architecture (HPCA)},
  pages={565--576},
  year={2017},
  organization={IEEE},
  doi={10.1109/HPCA.2017.59}
}

@online{willadsen23_meld,
    title = "Meld Visual diff and merge tool",
    url = "https://meldmerge.org/",
    addendum = "(accessed: 10.08.2023)",
    keywords = "meld, diff, merge, python"
}

@book{plauger00_c++stl,
author = {Plauger, P.J. and Lee, Meng and Musser, David and Stepanov, Alexander A.},
title = {C++ Standard Template Library},
year = {2000},
isbn = {0134376331},
publisher = {Prentice Hall PTR},
address = {USA},
edition = {1st},
abstract = {From the Publisher:Standard Template Libraries (STL) were created to provide C++ programmers with a suite of reusable programs, or lines of code, that could be used by everyone to increase programming productivity and quality. This book is the definitive reference on C++ programming using STL, as it was written by the team that created the library. Every C++ programmer will need at least one off-the-shelf STL reference guide. Each chapter covers one STL component, and includes background, a review of the standard, using the component, implementing the component, and exercises. For C++ Software Development Managers and C++ programmers at all levels.}
}
